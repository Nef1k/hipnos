# Воспоминания

Воспоминания - основной способ ознакомления игроков с сюжетом игры, а также один из способов выдачи разного рода
подсказок и ключей.

Подсистема воспоминаний хранит их игровое состояние, а также предоставляет программный интерфейс для изменения этого
состояния.

## Описание модели данных

### Сущность "Воспоминание" (Memory)

* `name:varchar(255)` - уникальный человеко-понятный символьный идентификатор, с помощью которого можно к воспоминанию
  можно обратиться в коде. Может использоваться вместо `id` при вызове методов подсистемы. Not NULL.
* `title:varchar(255)` - короткий заголовок, по которому можно понять, о чём говорится в самом воспоминании.
  Его можно отобразить в интерфейсе. Default ''.
* `unlocked_at:datetime` - временная метка, когда воспоминание было разблокировано. Если эта метка отсутствует, то
  воспоминание
  считается заблокированным и не может быть показано пользователю. Nullable.
* `markdown_text:text` - содержимое воспоминания в формате Markdown. При обновлении этого поля необходимо, в том числе,
  обновить поле `html_text`. Наличие этого поля позволяет в последствии реализовать WYSIWYG-редактор. Ну вдруг.
* `html_text:text` - содержимое воспоминания в формате HTML, пригодном для отображения пользователю. В данный момент
  на фронте он встраивается через аттрибут `dangerouslySetInnerHTML`. При реализации WYSIWYG это может быть уязвимостью.
* `order_key:int` - произвольное целочисленное значение, которое определяет порядок отображения воспоминаний в UI.
* `memory_type_id:int(fk)` - внешний ключ, определяющий тип воспоминания. Подробности про типы воспоминания описаны
  ниже. on delete: do nothing.

### Сущность "Тип Воспоминания" (MemoryType)
Семантически тип воспоминаний определяет основной контент, который будет отображаться в интерфейсе.
По факту же тип он только иконку, которая будет отображаться в интерфейсе.
Сейчас имеются следующие типы воспоминаний:
* `TEXT(0)`
* `AUDIO(1)`
* `VIDEO(2)`

Сущность содержит только одно поле - название `name:varchar(255)`.

### Данные для инициализации
Все данные для инициализации подсистемы воспоминаний находятся в `game_date/init_data`
и имеют следующую структуру:
```
game_data/
├── ...
└── init_data/
    ├── ...
    └── memories/
        ├── markdown/
        │   ├── memory1_text.md
        │   ├── memory2_text.md
        │   └── ...
        └── index.yml
```

#### index.yml
`index.yml` - основной файл, в котором описаны типы и сами воспоминания.
Состоит из двух основных ключей: `memory_types` и `memories`.
```
Структура объекта memories

memories:
└── <unique_memory_name>:
    ├── title: "Название воспоминания, отображаемое в UI"
    ├── type: тип воспоминания. должен быть один из описанных в разделе `memory_types`
    └── markdown_file: "путь к тексту воспоминания относительно game_data/init_data/memories"
```

Стоит обратить внимание, что порядок воспоминаний явно не указывается.
`order_key` генерируется в том порядке, в котором воспоминания описаны.

```
Структура объекта memory_types

memory_types:
└── <type_name>: <integer_type_id>
```

Далее приведён пример файла `index.yml`:
```yaml
# game_data/init_data/memories/index.yml

memory_types:
  text: 0
  audio: 1
  video: 2

memories:
  memory1:
    title: "Воспоминание 1"
    type: text
    markdown_file: "./markdown/memory1_text.md"
  memory2:
    title: "Воспоминание 2"
    type: audio
    markdown_file: "./markdown/memory2_text.md"
```

#### Основной текст Воспоминания
Текст воспоминания пишется в формате Markdown из-за простоты и мощности этого
формата. Краткий справочник на русском языке можно найти [тут](https://paulradzkov.com/2014/markdown_cheatsheet/).
Однако, следует заметить, что описанные там конструкции могут не работать.
Дело в том, что в статье речь идёт о GFM - GitHub Flavoured Markdown. Его 
функциональность немного больше, чем у "ванильного". Опять же, если не хватает
какой-либо разметки, можно *пнуть* меня, чтобы я его добавил.

##### Картинки, видео, аудио
Довольно душная тема, с которой мы обязательно столкнёмся рано или поздно.

Для аудио будет однозначно добавлено расширение и соответствующий формат. Скорее
всего там будет использованы не ссылки, а идентификаторы. Разберёмся (с).

Для видео вообще пока не ясно. Возможно так же, как и с аудио. Возможно с помощью
ссылок. Разберёмся (с).

Для картинок решение пока следующее:
* лучше не использовать картинки напрямую из интернета, т.к. в полевых условиях
  последнего может не оказаться
* локально сохранять картинки в понос (`fe/public/images`). В маркдауне
  использовать относительную ссылку вида `/images/possible_subfolder/image.png`
* По итогу в маркдауне получается конструкция вида `![Альт](/images/image.png "Заголовок")` 

Попозже имеет смысл иметь локальный сервер с медиа. Но это попозже

Дописать:
* Методы подсистемы
