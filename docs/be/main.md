# Back-end

## Рандомные мысли

Контент для Воспоминаний должен храниться в двух форматах: HTML и Markdown.
Первый используется как кэш для фактического отображения. Второй используется для редактирования.

По сути, все Воспоминания текстовые и хранятся в формате Markdown.
Если нужно сделать звуковое Воспоминание, в маркдауне просто прописывается
что-то вроде `~[Мгновенная подсказка](audio_id)`. Для видео - то же самое.
Тип указывается чисто, чтобы отобразить нужную иконку.

Возможно, следует уведомлять бэк о том, что пользователь начал воспроизведение аудио\видео.
Может быть мы захотим сделать какие-то дополнительные эффекты (помигать светодиодами,
бахнуть что-то во время воспроизведения и т.п.).

Для каждого компонента или подсистемы необходимо продумывать процедуру сброса к исходному состоянию.
К примеру, я сейчас добавляю Воспоминания. Я продумываю, какие данные нужны этой подсистеме в начале.
Потом я думаю, как их распихать по файлам в папке game_data.
И после этого, мне нужно будет подумать и наладить подхват этих данных в логике сброса.

UPD по подсистемам: не, нафиг-нафиг. Идея здравая, но чёт лень. Возможно в другой день я это запилю, но пока что 
я не вижу этому большого применения. Как таковых подсистем там должно быть 2 или 3. Проще ручками-ручками просто 
сделать 4-6 вызова. А сейчас я пожалуй займусь тем, что свяжу фронт и бек.

## Сервисы

Концепция сервиса используется здесь, чтобы отделить бизнес-логику приложения от
её использования. К примеру, мы хотим создать код, который производит некоторые
вычисления. При этом нам важно обращаться к нему как через django-команды из
терминала, так и сделать доступной логику этих вычислений для HTTP-запросов.

В контексте этого проекта сервис - это просто класс, для которого заранее определены
параметры инициализации и способ инициализации.

### Создание сервиса

В этом проекте все сервисы наследуют класс `di.services.base.BaseService`. В целом,
больше ничего не требуется. Для использования других сервисов внутри текущего необходимо передать
их как параметры в инициализаторе. Крайне рекомендуется использовать аннотации типов,
чтобы улучшить IDE experience, хотя это и необязательно. Ниже приведён пример
простейшего сервиса.

```python
# some_app/services.py
# или
# some_app/services/calc.py

from di.services.base import BaseService


class CalcService(BaseService):
    def __init__(self, adding_service: AddingService):
        self.adding_service = adding_service

    def calc(self, a: int, b: int) -> int:
        return self.adding_service.add(a, b)  # или a + b если мы не хотим дополнительной зависимости
```

### Инициализация сервиса

Для работы сервиса в большинстве случаев необходимы параметры, иногда другие
сервисы. Всё это попадает в сервис через его инициализатор.
Чтобы сервис не настраивать при каждом его использовании, есть контейнеры.
В данном проекте контейнер всего один - `di.containers.Container`. В нём
прописаны все необходимые сервисы для работы ГИПНОСа. Ниже приведён пример,
как прописать ранее созданные сервис в контейнере.

```python
# di/containers.py

class Container(containers.DeclarativeContainer):
    config = settings  # Явное определение, что конфиг надо брать из Django settings

    adding_service = providers.Factory(
        AddingService,
        config.SOME_PARAM,
    )

    # Наш новый сервис
    calc_service = providers.Singleton(
        CalcService,
        adding_service,  # Указываем, что нашему сервису в качестве первого 
                         # аргумента необходимо передать ссылку 
                         # на экземпляр AddinService 
    )


container = Container()  # Создаём единственный экземпляр контейнера
```

Здесь использованы два варианта создания экземпляра класса - `Factory` и `Singleton`.

В первом случае при запросе экземпляра сервиса будет происходить его создание
с указанными параметрами. При этом не нужно беспокоиться о предыдущем состоянии
сервиса (stateless service).

Во втором создание экземпляра будет происходить только
при первом обращении. При этом будет сохранена ссылка на этот экземпляр.
При последующих обращениях будет использован ранее созданный экземпляр. Таким образом
можно использовать один и тот же экземпляр сервиса в разных местах.
(stateful service).

Практически бесполезный дисклеймер: Singleton не является потокобезопасным (thread-safe).
Есть аналоги - `ThreadSafeSingleton` и `ThreadLocalSingleton`. Но в CPython имеется GIL,
а значит у нас априори не может быть потоконебезопасного кода.

### Использование сервиса

Под использованием сервиса понимается получение его экземпляра и вызов методов этого
экземпляра.

Чтобы получить экземпляр необходимого сервиса в методе или функции, нужно следующее:

1. Маркировка. Добавить параметр, в который будет передан экземпляр сервиса.
2. Регистрация. Использовать декоратор `@inject` для метода или функции, где этот сервис необходим.
   Этот декоратор регистрирует декорируемый метод во внутренних списках для последующей инъекции.
3. Инъекция. Взывать функцию `container.wire` передав туда список модулей, в которых нужно
   произвести "внедрение" сервисов. Именно на этом этапе происходит фактическая инъекция.

#### Маркировка

Чтобы обозначить, экземпляр какого сервиса необходимо подставить в функцию,
существуют Маркеры. В этом проекте чаще всего используется маркер `Provide`.
Маркеры передаются как значение по умолчанию параметра функции. Для улучшения
IDE experience имеет смысл также использовать аннотации типов.
Рассмотрим на примере.

```python
def calculation_view(
        a, b,
        calc_service: CalcService = Provide[Container.calc_service]
):
    return HttpResponse(calc_service.calc(a, b))
```

Однако, без связывания, мы получим ошибку о том, что объект типа `Provide` не
содержит метода `calc`. Всё дело в том, что для того, чтобы это заработало как
задумано, необходимо использовать декоратор `@inject`, который подскажет, в каких
местах необходимо подставить в параметры экземпляр сервиса. Таким образом,
у нас получится следующий код

```python
@inject
def calculation_view(
        request,
        calc_service: CalcService = Provide[Container.calc_service]
):
    # Достаём a и b из query-параметров запроса
    a = request.GET['a']
    b = request.GET['b']

    # Вызываем метод экземпляра сервиса calc_service
    return HttpResponse(calc_service.calc(a, b))
```

#### Маркировка для классов

В этом проекте используется подход, при котором для классов сервисы внедряются в
инициализатор(`__init__`). Т.к. метод в питоне для пользователя языка мало чем отличается
от обычной функции, код получается похожим.

```python
class CalcView(APIView):
    @inject
    def __init__(
            self,
            calc_service: CalcService = Provide[Container.calc_service]
    ):
        # Сохраняем ссылку на экземпляр сервиса CalcService
        self.calc_service = calc_service

    def get(self, request):
        # Достаём a и b из query-параметров запроса
        a = request.GET['a']
        b = request.GET['b']

        # Вызываем метод экземпляра сервиса calc_service
        return HttpResponse(self.calc_service.calc(a, b))
```

Таким же образом можно маркировать сервисы в django-командах. Для удобства, имеет
смысл сделать несколько базовых классов команд, в которых прописать все инъекции,
а затем наследоваться от них. Это связано с тем, что обычно существует несколько
команд, которые работают с одним и тем же набором сервисов

```python
# some_app/management/commands/base/base.py
from django.core.management import BaseCommand


class CalculationCommand(BaseCommand):
    def __init__(
            self,
            calc_service: CalcService = Provide[Container.calc_service]
    ):
        # При переопределении инициализатора, нельзя забывать про инициализаторы родителей
        super().__init__()

        # Сохраняем ссылку на экземпляр сервиса CalcService
        self.calc_service = calc_service


class ActualCalcCommand(CalculationCommand):
    def __init__(self):
        super().__init__()
        ...

    def add_arguments(self, parser):
        parser.add_argument('a', type=float)
        parser.add_argument('b', type=float)

    def handle(self, *args, **kwargs):
        # Достаём a и b из параметров командной строки
        a = kwargs['a']
        b = kwargs['b']

        # Вызываем метод экземпляра сервиса calc_service
        print(self.calc_service.calc(a, b))
```

#### Инъекция

Вызов метода `wire` должен происходить до обращения к экземпляру сервиса. В случае с Django
имеет смысл делать это после загрузки django-приложения в память. Для этого можно использовать
событие `ready` в классе `AppConfig`. Ниже приведён код, который решает эту задачу.

```python
# some_app/apps.py

class SomeAppConfig(AppConfig):
    ...

    def ready(self):
        super().ready()

        from . import views  # не помню зачем, но без этого не работает
        from di.containers import container
        container.wire(modules=[
            'some_app.management.commands.calc_sum',
            'some_app.views',
        ])
```

Здесь `di.containers` - соседнее django-приложение, в котором объявлен контейнер сервисов.
Важным является момент с локальным импортом. Это необходимо чтобы избежать преждевременного
обращения к контейнеру. Другими словами, "без этого не работает"(с).

## Подсистемы

Если коротко, подсистемы - это сервисы, в которых реализован определенный набор методов. Пока что среди них следующие:
* `reset()` - очистить соответствующие таблицы и заполнить их стартовыми данными
* `prune()` - очистить соответствующие таблицы

Остальное возможно напишу потом
